#
# CMPUT 229 Student Submission License
# Version 1.0
#
# Copyright 2021 <Swastik Sharma>
#
# Redistribution is forbidden in all circumstances. Use of this
# software without explicit authorization from the author or CMPUT 229
# Teaching Staff is prohibited.
#
# This software was produced as a solution for an assignment in the course
# CMPUT 229 - Computer Organization and Architecture I at the University of
# Alberta, Canada. This solution is confidential and remains confidential 
# after it is submitted for grading.
#
# Copying any part of this solution without including this copyright notice
# is illegal.
#
# If any portion of this software is included in a solution submitted for
# grading at an educational institution, the submitter will be subject to
# the sanctions for plagiarism at that institution.
#
# If this software is found in any public website or public repository, the
# person finding it is kindly requested to immediately report, including 
# the URL or other repository locating information, to the following email
# address:
#
#          cmput229@ualberta.ca
#
#---------------------------------------------------------------
# CCID:                 < swastik >
# Lecture Section:      < A1 >
# Instructor:           < J. Nelson Amaral   >
# Lab Section:          < D01 >
# Teaching Assistant:   < Siva Chowdeswar Nandipati, Islam Ali  >
#---------------------------------------------------------------
# 

# NOTE: for the below to work, you must delete the .include "common.s" from your arm_alu.s file
#.include "arm_alu.s"

.data
.align 2

RAT:	.space 2048
BTT:	.space 2048  

.include "common.s"
#----------------------------------
#        STUDENT SOLUTION
#----------------------------------

#----------------------------------------------------------------------------------------------------------------------------------------------------
# RISCVtoARM:
# This function translates RISC-V code in memory at address found in a0 into ARM code and stores 
# that ARM code into the memory address found in a1.
# 
# Arguments:
#	a0: pointer to memory containing a RISC-V function. The end of the RISC-V instructions is marked by the sentinel word 0xFFFFFFFF.
#	a1: a pointer to preallocated memory where you will have to write ARM instructions.
# 
# Return Values:
#	a0: number of bytes worth of instructions generated by RISCVtoARM.
#------------------------------------------------------------------------------------------------------------------------------------------------
RISCVtoARM:
	
	addi sp, sp, -32
	sw ra, 0(sp)
	sw s0, 4(sp)
	sw s1, 8(sp)
	sw s2, 12(sp)
	sw s3, 16(sp)
	sw s4, 20(sp)
	sw s5, 24(sp)
	sw s6, 28(sp)
	
	mv s0, a0		# s0 = risv inst
	mv s1, a1		# s1 = to store translated
	add s2, zero, zero	#s2 = i
	li s3, 0
	add s4, zero, zero	#s4 = j
	add s5, zero, zero
	add s6, zero, zero
	
	sFirstPass:
		
		slli t0, s2, 2 	# s2 <- 4i
		add t0, s0, t0	# t0 <- address of the risv to translate
		lw t0, 0(t0)
		mv a0, t0	# a0 <- t0
		li t1, -1
		beq t1, a0, sSecondPass
		jal translateControl
		
		# a0 = first arm inst
		# a1 = second arm inst
		slli t1, s4, 2	# t1 <- 4j
		add t1, t1, s1	# t1 = address to store the arm inst
		sw a0, 0(t1)	# store the inst
		addi s5, s5,4
		
		
		# Store the address in RAT
		la t3, RAT
		slli t4, s2, 2
		add t3, t4, t3
		sw t1, 0(t3)
		
		beqz a1, noSecondIns	# if no second instruction exists
		
		# Store the second ins
		addi s4, s4, 1
		slli t1, s4, 2	# t1 <- 4j
		add t1, t1, s1	# t1 = address to store the arm inst
		sw a1, 0(t1)
		addi s5, s5, 4
		
		
		# Calculating RISCV branch offset
		slli t1, s2, 2
		add t1, t1, s0
		lw t1, 0(t1)
		mv a0, t1
		jal calculateRISCVBranchOffset
		slli t0, s2, 2
		la t1, RAT
		add t2, t1, t0
		add t2, t2, a0
		slli t0, s2, 2
		la t1,BTT
		add t1, t1, t0
		sw t2, 0(t1)
		
		
		
		addi s4, s4, 1
		addi s2, s2, 1
		j sFirstPass
	
	noSecondIns:
		
		la t1, BTT
		slli t4, s2, 2
		add t1, t1, t4
		li t2, 0
		sw t2, 0(t1)
	
		addi s4, s4, 1
		addi s2, s2, 1
		j sFirstPass
	
	sSecondPass:
		bgt s6, s2, exit
		slli t1, s6, 2
		la t2, BTT
		add t1, t1, t2
		lw t2, 0(t1)
		beqz t2, nextBTT
		
		la t3, RAT
		slli t0, s6, 2
		add t3, t3, t0
		lw t4, 0(t3)
		addi t4, t4, 4
		lw t2, 0(t2)
		sub t2, t2, t4
		addi t2, t2, -8
		srai t2, t2, 2
		li t5, 0x00FFFFFF
		and t2, t2, t5
		la t3, RAT
		add t3, t3, t0
		lw t3, 0(t3)
		addi t3, t3, 4
		lw t4, 0(t3)
		or t4, t2, t4
		sw t4, 0(t3)
		
		j nextBTT
		
		
	nextBTT:
		addi s6, s6, 1
		j sSecondPass
		
	exit:	
		mv a0, s5
		lw ra, 0(sp)
		lw s0, 4(sp)
		lw s1, 8(sp)
		lw s2, 12(sp)
		lw s3, 16(sp)
		lw s4, 20(sp)
		lw s5, 24(sp)
		addi sp, sp, 28
		ret 	
	
#------------------------------------------------------------------------------------------------------------	
# translateControl:
# This function translates a single RISC-V beq, bge or jalr instruction into either one or two ARM instructions.
# 
# Arguments:
#	a0: untranslated RISC-V instruction.
#
# Return Values:
#	a0: first translated ARM instruction. This should either be a wholly tanslated BX instruction, or a CMP instruction.
#	a1: 0 or second translated ARM instruction. When non-zero, it should return a branch with 0 offset.
#------------------------------------------------------------------------------------------------------------------
translateControl:
	addi sp, sp, -16
	sw ra, 0(sp)
	sw s0, 4(sp)
	sw s1, 8(sp)
	sw s2, 12(sp)
	
	li t2, 103
	li t3, 99
	
	slli s2, a0, 25 #s2 stores opcode
	srli s2, s2, 25
	beq s2, t3, branchvali
	beq s2, t2, JALRx
	li a0, 0
	li a1, 0
	j finish
	JALRx:	
		
		li s2, 236126193
		#getting the main instruction fully
		mv s0, a0
		# getting source register 
		slli a0, a0, 12
		srli a0, a0, 27
		jal ra, translateRegister
		# moving contnts of the rasnslated register to ARm
		mv s1, a0
		slli t2, s2, 4
		add a0, s1, t2
		li t0, 1
		slli t0, t0, 4
		or a0, a0, t0
		li a1, 0
		j finish
		
		
			
	branchvali:
		li t2, 0
		li t3, 5
		mv s0, a0
		slli s1, s0, 17
		srli s1, s1, 29
		beq s1, t2, BEQx #getting funct value
		beq s1, t3, BGEx
		j finish
	
		
	BEQx:
		mv s0, a0
		slli a0, a0, 12
		srli a0, a0, 27
		jal ra, translateRegister
		mv s1, a0	#get translated register in s1 (source) operant 1
		
		mv a0, s0
		slli a0, a0, 7
		srli a0, a0, 27
		jal ra, translateRegister
		mv s2, a0	#get translated register in s1 (target) operant 2
		
		slli s1, s1, 16
		add s1, s1, s2
		li t0, 1
		slli t0, t0, 20
		add s1, t0, s1
		
		li t0, 10	#storing opcode
		slli t0, t0, 21
		add a0, s2, t0
		
		#starting to make a1
		li a1, 5
		slli a1, a1, 25
		j finish
		
		
	BGEx:
		mv s0, a0
		slli a0, a0, 12
		srli a0, a0, 27
		jal ra, translateRegister
		mv s1, a0	#get translated register in s1 (source) operant 1
		
		mv a0, s0
		slli a0, a0, 7
		srli a0, a0, 27
		jal ra, translateRegister
		mv s2, a0	#get translated register in s1 (target) operant 2
		
		slli s1, s1, 16
		add s1, s1, s2
		li t0, 1
		slli t0, t0, 20
		add s1, t0, s1
		
		li t0, 10	#storing opcode and condition
		slli t1, t0, 28
		slli t0, t0, 21
		add t0, t0, t1
		add a0, s2, t0
		li a1, 85
		slli a1, a1, 25
		j finish
		
		finish:
			lw ra, 0(sp)
			lw s0, 4(sp)
			lw s1, 8(sp)
			lw s2, 12(sp)
			addi sp, sp, 16
			jalr zero, ra, 0 	
		
#------------------------------------------------------------------------------------------------------------------------------
# translateRegister:
# This function converts the number of a RISC-V register passed in a0 into the number of a corresponding 
# ARM register.
#
# Arguments:
#	a0: RISC-V register to translate.
#
# Return Values:
#	a0: translated ARM register.
#------------------------------------------------------------------------------------------------------------------------------

translateRegister:
	
	addi sp , sp , -4  
	sw ra , 0(sp) 
	li t0, 1 
	beq a0, t0, Trans1 
	li t0 , 2 
	ble a0, t0, Trans2
	li t0, 9 
	ble a0, t0, Trans3 
	li t0 , 12 
	ble a0, t0, Trans4 
	li t0, 22 
	ble a0, t0, Trans5 
		
	Trans1:
		addi a0, a0, 13 		#adding 13 to 0(a0)
		j gone
	
	Trans2:
		addi a0, a0, 11 		#adding 11 to 0(a0)
		j gone

	Trans3: 
		addi a0, a0, -5 		#adding -5 to 0(a0)
		j gone
	
	Trans4: 			
		j gone				#remains same if less than 12	
		
	Trans5: 
		addi a0,a0,-13
		j gone
	
	
	
	gone:	
		lw ra 0(sp) 
		addi sp,sp,4 
		jr ra
			

#------------------------------------------------------------------------
# calculateRISCVBranchOffset
#
# This function performs simple computations to calculate the RISC-V branch offset.
# Negative values calculated by this function should be returned with proper sign extension.
#
# Arguments:
#	 a0: RISC-V instruction.
# 
# Return Values:
#	 a0: branch offset
#-------------------------------------------------------------------------

calculateRISCVBranchOffset:
	
	slli t1, a0, 20			#doing general bit shift operations on inst. to get the value of offs
	srli t1, t1, 28
	slli t1,t1, 1
	
	slli t0, a0, 1
	srli t0,t0, 26			
	slli t0,t0, 5
	add t1, t1, t0			
	
	slli t0, a0, 24
	srli t0, t0, 31
	
	slli t0,t0, 11
	add t1, t1,t0 
	
	srai t0, a0, 31
	slli t0, t0, 12			#fetching the 12 bit value of t1
	add t1, t1, t0
	mv a0, t1
		
	ret

				
